# 排序算法

![](https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718164528771-1976850903.jpg)

## 基础排序O(n^2)

> O(n^2)的排序算法是最基础的（像选择排序，插入排序, 冒泡排序这些都是）
>
> 排序算法最优的是O(nlgn)这样的级别的

### 选择排序

顾名思义，选择排序，即选出当前最小的，放到合适的位置。

![选择](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

使用嵌套循环 

- 第一层循环从0开始，用i来做标记， 指定元素为 arr[i]
- 第二层循环从 i+1开始，让arr中的i+1位置及以后的项与 i 项做比较，小于 arr[i] 则替换 使用 minIndex保存最小值的索引

```js
let arr = [2, 4, 6, 5, 10, 7, 9, 1, 8, 3]

function swap(arr, t1, t2) {
  let temp = arr[t1]
  arr[t1] = arr[t2]
  arr[t2] = temp
  delete temp
}

function selectionSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex])
        minIndex = j
    }
    swap(arr, i, minIndex)
  }
  return arr
}

console.log(selectionSort(arr))
```

我们使用随机生成用例函数生成用例，测试一下选择排序算法的执行时间。

> 后面工具函数算法中有相关工具函数的实现。

| 测试用例大小 | 算法运行时间 |
| ------------ | ------------ |
| 10000        | 60ms         |
| 100000       | 5500ms       |

当数据一定大的时候，两者成二次指数关系。 选择排序的复杂度为O(n^2)

####  使用模板编写算法

我们想要数组中的项是多种多样的时候也能排序，比如整数，小数，字符，字符串，对象

在js中，对于数字/小数/字符/字符串，均可使用平时编写的排序算法。

如果是对象数组，要按照对象的某一项作比较

我们可以借用 `Array.prototype.sort()`方法

```js
let arr = [
    { name: 'bbb', age: 20},
    { name: 'aaa', age: 19},
    { name: 'ccc', age: 21}
];

const compare = function(prop){
    return function(o1, o2){
        if(o1[prop] < o2[prop]){
            return -1;
        }else if(o1[prop] > o2[prop]){
            return 1;
        }else if(o1[prop] == o2[prop]){
            return 0; 
        }
    }
};
```

### 冒泡排序

冒泡冒泡，一次循环流程之后将最大的冒泡到最后的位置

![冒泡](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

```js
function bubbleSort (arr) {
  // 外层循环控制冒泡轮数 5个数冒泡只要4轮就可
  for (let i=0;i<arr.length-1;i++) {
    for (let j=0;j<arr.length-1-i;j++) {
      if (arr[j] > arr[j+1]) {
        swap(arr,j,j+1)
      }
    }
  }
  return arr
}
```

> 上述代码是最经典的冒泡排序，我们下面来尝试优化一下

#### 小优化

第一种优化方式是设置一个标记位来标记是否发生了交换，如果没有发生交换就说明算法是有序的，提前结束

> 假设我们现在排序ar[]={1,2,3,4,5,6,7,8,10,9}这组数据，按照上面的排序方式，第一趟排序后将10和9交换已经有序，接下来的8趟排序就是多余的，什么也没做。所以我们可以在交换的地方加一个标记，如果那一趟排序没有交换元素，说明这组数据已经有序，不用再继续下去。

```js
function bubbleSort2(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    // 有序标志，如果没有进行交换，也就是flag没有变成false，就说明数组有序，直接break
    let flag = true
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        flag = false
      }
    }
    if (flag) {
      break
    }
  }
  return arr
}
```

#### 再优化

![](https://img-blog.csdn.net/2018062700091521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnNpb256/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```js
function bubbleSort3(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    // 有序标志，如果没有进行交换，也就是flag没有变成false，就说明数组有序，直接break
    let flag = true
    let pos = 0 // 记录最后一次交换的位置
    let k = arr.length-1
    for (let j = 0; j < k; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        flag = false
        pos = j
      }
    }    
    k = pos

    if (flag) {
      break
    }
  }
  return arr
}
```

### 插入排序

理解插入排序可以想象我们玩斗地主的时候整理牌，拿到一张牌的时候，我们会把它将前面的牌作比较，放到合适的位置。插入排序也是这一思想。

#### 一代

先来看代码：

```js
function insertionSort (arr) {
  // 默认第一个位置与自己相比已经有序，i从1开始而不是0
  for (let i=1;i<arr.length;i++) {
    for (let j=i;j>0;j--) {
      if (arr[j] < arr [j-1])
        swap(arr,j, j - 1)
      else
        break
    }
  }
}
```

####  二代

第五行的if判断我们可以简化成下面：

```js
function insertionSort(arr) {
  // 默认第一个位置与自己相比已经有序，i从1开始而不是0
  for (let i = 1; i < arr.length; i++) {
    for (let j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
      swap(arr,j, j - 1)
    }
  }
}
```

我们比较一下插入排序和选择排序，我们不难发现，

1. 插入排序的第二层循环是可以提前结束的。
2. 选择排序是将拿的元素v[i]与它后面的元素进行比较，而插入排序是跟之前元素做比较

**总体上来说，插入排序因为有提前结束的机会，所有它整体上性能要比选择排序好。**



#### 测试性能

现在来测试仪一下选择排序和插入排序的的性能

```js
function compare () {
  let arr1 = arr
  let arr2 = arr
  util.testSort('插入排序', insertionSort, arr2)
  util.testSort('选择排序', selectionSort, arr1)
  delete arr1
  delete arr2
}
```

当我们的数据很大的时候，我们发现和我们的预期一样，插入排序比选择排序要快一些

**但是当我们的数据为1000或者更小的时候，发现插入排序反而比选择排序更慢**

> 因为我们的插入排序每次交换位置（swap函数）都得索引到数组相应的位置进来3次赋值，交换的操作比比较操作更耗时，当数据量很小的时候，这方面的性能损耗就体现了出来。

#### 三代

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

我们如果能**让插入排序的内层循环只交换一次**，我们就可以提升我们的插入排序的性能。

我们之前的做法是每一次比较后符合条件就**交换**，而一次交换就是三次赋值操作。现在使用比较后符合条件就执行一次赋值，每一次的三次赋值操作降低到一次赋值操作，性能会更加优化。

优化后的代码：

```js
function insertionSort(arr) {
  // 默认第一个位置与自己相比已经有序，i从1开始而不是0
  for (let i = 1; i < arr.length; i++) {
    // 取一份待插入数的备份
    let e = arr[i]
    // j保存元素e应该插入的位置
    let j
    // 判断j-1的位置是否仍然比e大 
    for (j = i; j > 0 && e < arr[j - 1]; j--) {
      arr[j] = arr[j-1]
    }
    arr[j] = e
  }
  return arr
}
```

这样，我们的插入算法就得到了进一步的优化。



之前也说到过，插入排序的第二层循环是可以提前终止的，如果**我们的数据近乎有序，那么这个算法的复杂的就会越发接近 O(n)**，所以插入排序在某些时候，比如处理近乎有序的数据时，会有非常大的优势

```js
let arr = util.randomArray(10000, 0, 10000)
```

普通无序的长度1w的数组，我们测试时间：

> 插入排序执行时间: 29ms
> 选择排序执行时间: 60ms

我们使用 生成近乎有序的用例 的算法来生成一个 一个 长度1w，10对数组打乱顺序的数组

```js
let NearlyArr = util.generateNearlyOrderedArray(10000,10)
```

近乎有序长度1w的数组，我们测试时间：

> 插入排序执行时间: 3ms
> 选择排序执行时间: 60ms

结果说明了插入排序在特殊条件下的天大优势，这一特征，也被用来处理后续复杂度为O(n*logn)级别算法的子过程。后续文章会介绍。



## 高级排序O(nlogn)

### 对比

|          | n^2   | nlogn   | 倍数关系 |
| -------- | ----- | ------- | -------- |
| n=10     | 10^2  | 33      | 3        |
| n=100    | 10^4  | 664     | 15       |
| n=1000   | 10^6  | 9966    | 100      |
| n=10000  | 10^8  | 132877  | 753      |
| n=100000 | 10^10 | 1660964 | 6020     |

不难看出，随着数据的增大，n^2级别的算法和nlogn级别的算法的差距越来越大。 

### 希尔排序

> 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

1. 选择一个增量序列 t1,t2,t3...tk，其中t1最大，tk最小，值为1
2. 按增量序列个数k，进行k此排序
3. 每次排序，会根据增量t，将待排序数组分割成若干等长的子数组，对每一个子数组直接使用插入排序。当增量减为1时，整个序列进行最后的插入排序。

![img](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)



```js
function shellSort(arr) {
  let len = arr.length
  // 这里的gap不使用动态定义了，因为那样有点难理解
  let gaps = [5,3,1]

  // 一层循环控制排序次数 
  for (let g=0;g<gaps.length;g++) {
    // 到这里就和插入排序一样了 
    for (let i=gaps[g]; i<len; i++) {
      let temp = arr[i]
      let j
      for (j=i;j>=gaps[g]&&temp<arr[j-gaps[g]];j-=gaps[g]) {
        arr[j] = arr[j - gaps[g]]
      }
      arr[j] = temp
    }
  }
  return arr
}
```



### 归并排序

> 必须使额外的O(n)空间来完成排序,时间的效率比空间的效率重要太多，绝大多数情况下都是时间优先。

**算法思路**

我们使用分治的思想，将待排数组分成两组，每一组排序完成后再合并，我们可以将分组再分组，一直分到每一组只有一项为止，这个时候每组都只有一个元素，那么他们每组都是有序的，分半->分半->再分半->分到每组只剩下一个元素的时候就回溯   **需要分半的次数：log(n)**

![](https://blog-1257919906.cos.ap-guangzhou.myqcloud.com/image/notes/suanfa/%E5%BD%92%E5%B9%B6.gif)



归并是：先复制数组arr的一份副本，然后拿这个副本数组aux中的i和j来比较，谁小谁先进真正的arr

对于子组向上合并的时候的，不要再原数组上进行交换操作，这里要将其复制一份。进行比较后赋值。具体流程可以看下图。

![](https://blog-1257919906.cos.ap-guangzhou.myqcloud.com/image/notes/suanfa/%E5%BD%92%E5%B9%B61.gif)



我们可以看到，我们进行每一次的合并操作的时候，我们都要对三个位置进行标记。维护合并时的这三个标记变量，是实现归并排序的关键。

```js
// 入口函数
function mergeSort (arr) {
  __mergeSort(arr,0,arr.length-1)
  return arr
}

// 递归使用归并排序，对arr[l...r]的范围进行排序
function __mergeSort(arr,l,r) {
  // 递归出口
  if (l >= r) {
    return
  }
  let mid = Math.floor((l + r) / 2)
  __mergeSort(arr, l, mid) // T(N/2)
  __mergeSort(arr, mid+1, r) // T(N/2)
  __merge(arr,l,mid,r) // O(N)
  // T(N) = 2T(N/2) + O(N) = O(NlogN)
}

function __merge(arr,l,mid,r) {
  let aux = new Array(r-l+1)
  let i = 0
  let p1 = l
  let p2 = mid + 1
  // 谁小往临时数组里就添谁的过程
  while (p1 <=mid && p2 <=r) {
    aux[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]
  }
  // 临界过程
  while(p1<=mid) {
    aux[i++] = arr[p1++]
  }
  while (p2<=r) {
    aux[i++] = arr[p2++]
  }
  for (let i = 0;i<aux.length;i++) {
    arr[l+i] = aux[i]
  }
}
```

#### 性能测试

```js
let arr = util.randomArray(50000,0,1000)
let arr1 = arr.slice()
let arr2 = arr.slice()

util.testSort('归并', mergeSort, arr1)
util.testSort('插入', insertionSort, arr2)
// 归并: 15.462ms
// 插入: 686.056ms

let arr = util.generateNearlyOrderedArray(50000, 10)
let arr1 = arr.slice()
let arr2 = arr.slice()

util.testSort('归并', mergeSort, arr1)
util.testSort('插入', insertionSort, arr2)
// 归并: 18.331ms
// 插入: 4.117ms
```

可以看到，当处理无序用例的时候，归并排序比插入排序的效率高很多，但是当处理近乎有序的数组的时候，又是相反的结果。

#### 优化

**一，控制__merge条件**

```js
// 改进 增加merge条件
function __mergeSort(arr, l, r) {
  if (l >= r) {
    return
  }
  let mid = Math.floor((l + r) / 2)
  __mergeSort(arr, l, mid)
  __mergeSort(arr, mid + 1, r)
  // 因为两块都是有序的，如果我们的前者的最大值比后者的最小值还要小，说明此时已经有序
  if (arr[mid]>arr[mid+1])
    __merge(arr, l, mid, r)
}
```

我们给`__merge`函数的执行加上一个条件，这样一个简单的控制，就是的我们的归并排序在处理近乎有序的情况下，比之前的快了非常多。

使用时酌情考虑，以为加了一个条件就代表着多了一次判断，对性能有损耗，但是如果我们知道我们要处理的数据有很多有序的情况下，还是建议加上这一判断条件比较合适。

**二，递归到底情况**

现在我们的归并排序是递归到只有一个元素的时候返回，事实上，当**我们的递归到元素量很小的时候，我们可以转而使用插入排序**。

- 元素量比较小的时候，元素近乎有序的概率就会增加。此时插入排序有优势。
- 插入排序最坏时间复杂度是n^2级别的，归并是nlogn的。但是这两这前面都是有一个常数项的，对于这个系数而言，插入排序是比归并排序要小的，也就是说，当n小到一定程度的时候，插入排序会比归并排序要快。

```js
// 改进递归到底使用插入排序
function __mergeSort(arr, l, r) {
  // if (l >= r) {
  //   return
  // }
  if (r-l<=15) {
    insertionSort(arr,l,r)
    return
  }
  let mid = Math.floor((l + r) / 2)
  __mergeSort(arr, l, mid)
  __mergeSort(arr, mid + 1, r)
  // 因为两块都是有序的，如果我们的前者的最大值比后者的最小值还要小，说明此时已经有序
  if (arr[mid] > arr[mid + 1])
    __merge(arr, l, mid, r)
}
```

> 测试：当我们的随机数样本量为50w的时候，改进后的算法提升了10%--20%左右,但是时间复杂度在本质上没有变化。

####  自底向上

我们上面的归并排序是自顶向下的使用递归实现的排序，我们可以换个思维，使用自底向上的思想来完成排序，在这个过程中，我们就不用使用递归，而是直接迭代，就能够完成排序

![](https://blog-1257919906.cos.ap-guangzhou.myqcloud.com/image/notes/suanfa/%E5%BD%92%E5%B9%B6BU.gif)



```js
function mergeSortBottomToUp (arr) {
  var len = arr.length
  // 第一轮循环控制有几次向上的过程 1 - 2 - 4 - 8 。。。 这样的过程
  for (let size = 1; size <= len; size+=size) {
    // 对arr[i...i+size-1],和 arr[i+size....i+size*2-1] 进行归并
    // for (let i = 0; i< len; i += size*2) {
    // i+size也至少是小于n的 保证 i+size-1 是不会越界的
    for (let i = 0; i + size < len; i += size * 2) {
      // __merge(arr, i, i+size-1, i+size*2 - 1)
      // i+size*2 -1 可能会比n大 所以
      __merge(arr, i, i+size-1, Math.min((i+size*2-1),len-1))
    }
  }
}

function __merge(arr, l, mid, r) {
  let aux = new Array(r - l + 1)
  let i = 0
  let p1 = l
  let p2 = mid + 1
  // 谁小往临时数组里就添谁的过程
  while (p1 <= mid && p2 <= r) {
    aux[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]
  }
  // 临界过程
  while (p1 <= mid) {
    aux[i++] = arr[p1++]
  }
  while (p2 <= r) {
    aux[i++] = arr[p2++]
  }
  for (let i = 0; i < aux.length; i++) {
    arr[l + i] = aux[i]
  }
}
```

这个排序我们可以发现一个很重要的特性，我们在排序的过程中没有使用使用数组的索引来获取数组的某一项，这一特性可以使得自底向上的归并排序可以很好的操作链表。



## 工具函数算法

### 生成用例算法

我们测试一个算法的时候，要手动输入值，当我们数据量需求增大的时候，我们就要使用函数来随机生成我们的算法用例了

数据数量 数据范围

```js
module.exports = {
  // 生成随机用例方法
  randomArray: function (n, rangeL, rangeR) {
    let arr = []
    for (let i = 0; i < n; i++) {
      arr[i] = Math.floor(Math.random() * (rangeR - rangeL + 1)) + rangeL
    }
    return arr
  }
}
```

以后这种工具函数定义在一个util.js文件中，统一管理



### 性能测试算法

```js
  // 测试算法执行时间函数
  testSort: function(sortName, sortFn, arr) {
    let startTime = Date.now();
    sortFn(arr);
    let endTime = Date.now();
    if (!this.isSorted(arr)) {
      throw new Error('排序出错！');
    }
    console.log(`${sortName}执行时间: ${endTime - startTime}ms`);
  },
  isSorted: function (arr) {
    for (let i=0; i<arr.length - 1; i++) {
      if (arr[i] > arr[i+1])
        return false
    }
    return true
  }
```

js自带的一个方法用于测试性能，比Data.now()更精确

```js
  // 测试算法执行时间函数
  testSort: function(sortName, sortFn, arr) {
    console.time(sortName);
    sortFn(arr);
    console.timeEnd(sortName);
    if (!this.isSorted(arr)) {
      throw new Error('排序出错！');
    }
  },
```



### 近乎相等测试用例算法

```js
  // 生成近乎有序的用例
  generateNearlyOrderedArray: function (n,swapTimes) {
    let arr = []
    // 生成有序
    for (let i = 0;i<n;i++) {
      arr[i] = i
    }
    // 打乱
    for (let i=0;i<swapTimes;i++) {
      // 生成[0,n)
      let a = Math.floor(Math.random()*n)
      let b = Math.floor(Math.random()*n)
      this.swap(arr,a,b)
    }
    
    return arr
  }
```

